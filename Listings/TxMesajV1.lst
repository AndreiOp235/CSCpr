C51 COMPILER V9.59.0.0   TXMESAJV1                                                         03/16/2025 13:20:03 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE TXMESAJV1
OBJECT MODULE PLACED IN .\Objects\TxMesajV1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE TxMesajV1.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\BIG8051\Include) DEB
                    -UG OBJECTEXTEND PRINT(.\Listings\TxMesajV1.lst) TABS(2) OBJECT(.\Objects\TxMesajV1.obj)

line level    source

   1          #include <c8051F040.h>  // declaratii SFR
   2          #include <uart1.h>
   3          #include <Protocol.h>
   4          #include <UserIO.h>
   5          
   6          extern unsigned char TIP_NOD;     // tip nod initial: Nu Master, Nu Jeton
   7          
   8          extern nod retea[];
   9          
  10          extern unsigned char timeout;   // variabila globala care indica expirare timp de asteptare eveniment
  11          //********************************************************************************************************
             -***
  12          void TxMesaj(unsigned char i);  // transmisie mesaj destinat nodului i
  13          void bin2ascii(unsigned char ch, unsigned char *ptr); // functie de conversie octet din binar in ASCII HEX
  14          
  15          //********************************************************************************************************
             -***
  16          void TxMesaj(unsigned char i){          // transmite mesajul din buffer-ul i
  17   1        unsigned char sc, *ptr, j;
  18   1        
  19   1        if(retea[i].bufbin.tipmes == POLL_MES)
  20   1        {
  21   2          sc = retea[i].bufbin.adresa_hw_dest;
  22   2          sc += retea[i].bufbin.adresa_hw_src;
  23   2          retea[i].bufbin.sc = sc;
  24   2        }
  25   1        else
  26   1        {
  27   2          sc = retea[i].bufbin.adresa_hw_dest;
  28   2          sc += retea[i].bufbin.adresa_hw_src;
  29   2          sc += retea[i].bufbin.tipmes;
  30   2          sc += retea[i].bufbin.src;
  31   2          sc += retea[i].bufbin.dest;
  32   2          sc += retea[i].bufbin.lng;
  33   2          
  34   2          for(j = 0; j < retea[i].bufbin.lng; ++j) 
  35   2          {
  36   3            sc += retea[i].bufbin.date[j];
  37   3          }
  38   2          
  39   2          retea[i].bufbin.sc = sc;
  40   2        }                                     
  41   1      
  42   1        ptr = retea[i].bufasc + 1;                              
  43   1        
  44   1        bin2ascii(retea[i].bufbin.adresa_hw_dest, ptr);                     
  45   1        ptr += 2;
  46   1                                                    
  47   1        bin2ascii(retea[i].bufbin.adresa_hw_src, ptr);                      
  48   1        ptr += 2;
  49   1                                                      
  50   1        bin2ascii(retea[i].bufbin.tipmes, ptr);                       
  51   1        ptr += 2;
  52   1                                                      
C51 COMPILER V9.59.0.0   TXMESAJV1                                                         03/16/2025 13:20:03 PAGE 2   

  53   1        if(retea[i].bufbin.tipmes == USER_MES)
  54   1        {
  55   2          bin2ascii(retea[i].bufbin.src, ptr);
  56   2          ptr += 2;
  57   2          
  58   2          bin2ascii(retea[i].bufbin.dest, ptr);
  59   2          ptr += 2;
  60   2          
  61   2          bin2ascii(retea[i].bufbin.lng, ptr);
  62   2          ptr += 2;
  63   2          
  64   2          bin2ascii(retea[i].bufbin.date[NR_CHAR_MAX], ptr);
  65   2          ptr += 2;
  66   2        }   
  67   1            
  68   1        bin2ascii(retea[i].bufbin.sc, ptr);
  69   1        ptr += 2;
  70   1        
  71   1        *ptr++ = 0x0D;
  72   1        *ptr++ = 0x0A;
  73   1        
  74   1        ptr = retea[i].bufasc;
  75   1        
  76   1        while (*ptr) 
  77   1        {
  78   2          UART1_PutchPE(*ptr);
  79   2          ptr++;
  80   2        }
  81   1      }
  82          
  83          //********************************************************************************************************
             -***
  84          void bin2ascii(unsigned char ch, unsigned char *ptr){ // converteste octetul ch in doua caractere ASCII HE
             -X puse la adresa ptr
  85   1        unsigned char first, second;
  86   1        first = (ch & 0xF0)>>4;           // extrage din ch primul digit
  87   1        second = ch & 0x0F;               // extrage din ch al doilea digit
  88   1        if(first > 9) *ptr++ = first - 10 + 'A';  // converteste primul digit daca este litera
  89   1        else *ptr++ = first + '0';        // converteste primul digit daca este cifra
  90   1        if(second > 9) *ptr++ = second - 10 + 'A';  // converteste al doilea digit daca este litera
  91   1        else *ptr++ = second + '0';       // converteste al doilea digit daca este cifra
  92   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    800    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
